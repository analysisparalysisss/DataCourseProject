m <- x$getmatrix()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setmatrix(m)
m
}
makeCacheMatrix(x=matrix(1:16,4,4))
cacheSolve(x)
x
## A pair of functions that cache the inverse of a matrix.
## The first function, makeCashMatrix creates a special "vector", which is really a list containing a function to
##set the value of the matrix
##get the value of the matrix
##set the value of the matrix
##get the value of the matrix
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmatrix <- function(solve) m <<- solve
getmatrix <- function() m
list(set = set, get = get,
setmatrix = setmatrix,
getmatrix = getmatrix)
}
## This function computes the inverse of the special "matrix" returned by makeCacheMatrix above. If the inverse has already been calculated (and the matrix has not changed), then the cachesolve should retrieve the inverse from the cache.
cacheSolve <- function(x), ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getmatrix()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setmatrix(m)
m
}
## A pair of functions that cache the inverse of a matrix.
## The first function, makeCashMatrix creates a special "vector", which is really a list containing a function to
##set the value of the matrix
##get the value of the matrix
##set the value of the matrix
##get the value of the matrix
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmatrix <- function(solve) m <<- solve
getmatrix <- function() m
list(set = set, get = get,
setmatrix = setmatrix,
getmatrix = getmatrix)
}
## This function computes the inverse of the special "matrix" returned by makeCacheMatrix above. If the inverse has already been calculated (and the matrix has not changed), then the cachesolve should retrieve the inverse from the cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getmatrix()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setmatrix(m)
m
}
makeCacheMatrix(matrix(1:16,5,5))
cacheSolve(matrix(1:16,4,4))
class(getmatrix)
m
list
list()
?matrix()
makeCacheMatrix(1:16,4,4)
cacheSolve
cacheSolve()
## A pair of functions that cache the inverse of a matrix.
## The first function, makeCashMatrix creates a special "vector", which is really a list containing a function to
##set the value of the matrix
##get the value of the matrix
##set the value of the matrix
##get the value of the matrix
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmatrix <- function(solve) m <<-solve
getmatrix <- function() m
list(set = set, get = get,
setmatrix = setmatrix,
getmatrix = getmatrix)
}
## This function computes the inverse of the special "matrix" returned by makeCacheMatrix above. If the inverse has already been calculated (and the matrix has not changed), then the cachesolve should retrieve the inverse from the cache.
cacheSolve <- function(x=matrix(), ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getmatrix()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setmatrix(m)
m
}
makeCacheMatrix()
cacheSolve()
is.recursive(x)
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmatrix <- function(solve) m <<-solve
getmatrix <- function() m
list(set = set, get = get,
setmatrix = setmatrix,
getmatrix = getmatrix)
}
makeCacheMatrix(1:16,4,4)
makeCacheMatrix(matrix(1:16,4,4))
is.recursive(x)
class(x)
class(makeCacheMatrix)
x
head(x)
?solve
solve(matrix(1:16,4,4))
solve(matrix(1:4,2,2))
## A pair of functions that cache the inverse of a matrix.
## The first function, makeCashMatrix creates a special "vector", which is really a list containing a function to
##set the value of the matrix
##get the value of the matrix
##set the value of the matrix
##get the value of the matrix
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmatrix <- function(solve) m <<-solve
getmatrix <- function() m
list(set = set, get = get,
setmatrix = setmatrix,
getmatrix = getmatrix)
}
## This function computes the inverse of the special "matrix" returned by makeCacheMatrix above. If the inverse has already been calculated (and the matrix has not changed), then the cachesolve should retrieve the inverse from the cache.
cacheSolve <- function(x=matrix(), ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getmatrix()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setmatrix(m)
m
}
makeCacheMatrix(1:4,2,2)
makeCacheMatrix(matrix(1:4,2,2))
cacheSolve(matrix(1:4,2,2))
y
m
set
set()
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() {x}
setmatrix <- function(solve) m <<-solve
getmatrix <- function() {m}
list(set = set, get = get,
setmatrix = setmatrix,
getmatrix = getmatrix)
}
makeCacheMatrix(matrix(1:4,2,2))
x
list
x<-list
x
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() {x}
setmatrix <- function(solve) m <<-solve
getmatrix <- function() {m}
list(set = set, get = get,
setmatrix = setmatrix,
getmatrix = getmatrix)
}
makeCacheMatrix()
cacheSolve <- function(x=matrix(), ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getmatrix()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setmatrix(m)
m
}
cacheSolve(matrix(1:4,2,2)
cacheSolve(matrix(1:4,2,2))
cacheSolve(matrix(1:4,2,2))
x
class(x)
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getmatrix()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setmatrix(m)
m
}
cacheSolve(matrix(1:4,2,2))
class(x)
makeCacheMatrix <- function(x = matrix()) {
m<-NULL
set<-function(y){
x<<-y
m<<-NULL
}
get<-function() x
setmatrix<-function(solve) m<<- solve
getmatrix<-function() m
list(set=set, get=get,
setmatrix=setmatrix,
getmatrix=getmatrix)
}
cacheSolve <- function(x=matrix(), ...) {
m<-x$getmatrix()
if(!is.null(m)){
message("getting cached data")
return(m)
}
matrix<-x$get
m<-solve(matrix, ...)
x$setmatrix(m)
m
}
makeCacheMatrix(1:4,2,2)
makeCacheMatrix(matrix(1:4,2,2))
makeCacheMatrix <- function(x = matrix()) {
m<-NULL
set<-function(y){
x<<-y
m<<-NULL
}
get<-function() x
setmatrix<-function(solve) m<<- solve
getmatrix<-function() m
list(set=set, get=get,
setmatrix=setmatrix,
getmatrix=getmatrix)
}
cacheSolve <- function(x=matrix(), ...) {
m<-x$getmatrix()
if(!is.null(m)){
message("getting cached data")
return(m)
}
matrix<-x$get()
m<-solve(matrix, ...)
x$setmatrix(m)
m
}
cacheSolve()
makeCacheMatrix <- function(x = matrix()) {
m<-NULL
set<-function(y){
x<<-y
m<<-NULL
}
get<-function() x
setmatrix<-function(solve) m<<- solve
getmatrix<-function() m
list(set=set, get=get,
setmatrix=setmatrix,
getmatrix=getmatrix)
}
cacheSolve <- function(x=matrix(), ...) {
m<-x$getmatrix()
if(!is.null(m)){
message("getting cached data")
return(m)
}
matrix<-x$get()
m<-solve(matrix, ...)
x$setmatrix(m)
m
}
makeCacheMatrix(matrix(1:4,2,2))
cacheSolve(matrix(1:4,2,2))
x
class(x)
?list
makeCacheMatrix <- function(x = matrix()) {
m<-NULL
set<-function(y){
x<<-y
m<<-NULL
}
get<-function() x
setmatrix<-function(solve) m<<- solve
getmatrix<-function() m
x<-list(set=set, get=get,
setmatrix=setmatrix,
getmatrix=getmatrix)
}
cacheSolve <- function(x=matrix(), ...) {
m<-x$getmatrix()
if(!is.null(m)){
message("getting cached data")
return(m)
}
matrix<-x$get()
m<-solve(matrix, ...)
x$setmatrix(m)
m
}
makeCacheMatrix(matrix(1:4,2,2))
class(x)
makeCacheMatrix <- function(x = matrix()) {
m<-NULL
set<-function(y){
x<<-y
m<<-NULL
}
get<-function() x
setmatrix<-function(solve) m<<- solve
getmatrix<-function() m
list(set=set, get=get,
setmatrix=setmatrix,
getmatrix=getmatrix)
}
cacheSolve <- function(x, ...) {
m<-x$getmatrix()
if(!is.null(m)){
message("getting cached data")
return(m)
}
matrix<-x$get()
m<-solve(matrix, ...)
x$setmatrix(m)
m
}
class(x)
?x
x
x$get()
x$getmatrix()
makeCacheMatrix <- function(x = matrix()) {
m<-NULL
set<-function(y){
x<<-y
m<<-NULL
}
get<-function() x
setmatrix<-function(solve) m<<- solve
getmatrix<-function() m
list(set=set, get=get,
setmatrix=setmatrix,
getmatrix=getmatrix)
}
makeCacheMatrix(matrix(1:4,2,2))
x$getmatrix()
x$getmatrix
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() {x}
setmatrix <- function(solve) m <<-solve
getmatrix <- function() {m}
list(set = set, get = get,
setmatrix = setmatrix,
getmatrix = getmatrix)
}
a<-makeCacheMatrix()
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getmatrix()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setmatrix(m)
m
}
a$set(matrix(1:4,2,2))
cacheSolve(a)
a<-makeCacheMatrix(matrix(1:4,2,2))
cacheSolve(a)
library(datasets)
data(iris)
?iris
mean(iris$sepal.Length)
head(iris$sepal.length)
head(iris$sepal.Length)
head(iris$Sepal.Length)
mean(iris$Sepal.Length)
mean(iris(Species=virginica)$Sepal.Length)
mean(iris[Species=virginica]$Sepal.Length)
iris1<-iris(Species=virginica)
iris1=iris[Species=virginica]
iris1=iris[Species=virginica,]
iris1=iris["Species"="virginica",]
iris1<-iris[which(Species=virginica)]
iris1<-subset(iris,Species==virginica)
head(iris)
print(iris)
iris[iris$Species="virginica",]
iris[iris$Species=="virginica",]
iris[Species=="virginica",]
mean(iris[iris$Species=="virginica",2])
a<-iris[iris$Species=="virginica",]
mean(a)
mean(a[2])
mean(a[,2])
apply(iris, 1, mean)
a<-colMeans(iris)
iris
apply(iris[, 1:4], 1, mean)
?apply
apply(iris[, 1:4], 2, mean)
apply(iris[,iris$Species=="virginica"],2,mean)
apply(iris[iris$Species=="virginica",2],2,mean)
library(datasets)
data(mtcars)
?mtcars
head(mtcars)
sapply(split(mtcars$mpg, mtcars$cyl), mean)
sapply(mtcars, cyl, mean)
apply(mtcars, 2, mean)
mean(mtcars$mpg, mtcars$cyl)
sapply(split(mtcars$hp, mtcars$cyl), mean)
a<-sapply(split(mtcars$hp, mtcars$cyl), mean)
a[3]-a[1]
debug(ls)
ls
ls()
2
3
end
escape
debug
library(datasets)
data(iris)
?debug
?
exit
exit
q
q
q
undebug(ls)
?debug
debug(ls)
ls()
undebug(ls)
debug(ls)
ls()
> iris
library(datasets)
data(iris)
head(iris)
mean(iris[,2])
sapply(split(iris$Sepal.Length, iris$Species), mean)
iris
apply(iris, 2, mean)
apply(iris[, 1:4], 2, mean)
tapply(mtcars$mpg, mtcars$cyl, mean)
sapply(mtcars, cyl, mean)
lapply(mtcars, mean)
split(mtcars, mtcars$cyl)
install.packages("R.MySQL")
install.packages("R.MySQL")
